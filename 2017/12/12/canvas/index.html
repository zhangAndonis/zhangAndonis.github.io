<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="canvas 是HTML5新增的标签（画布）,功能特别强大  作用：  HTML5游戏大部分都是基于canvas开发的，还有一些交互性强的效果   炫酷的动效  webGL技术的实现（利用canvas在页面中绘制3D效果），three.js，计算机图形学  图片裁剪、修图、转base64，绘制图表做数据可视化(echa">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/2017/12/12/canvas/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="canvas 是HTML5新增的标签（画布）,功能特别强大  作用：  HTML5游戏大部分都是基于canvas开发的，还有一些交互性强的效果   炫酷的动效  webGL技术的实现（利用canvas在页面中绘制3D效果），three.js，计算机图形学  图片裁剪、修图、转base64，绘制图表做数据可视化(echarts highcharts d3.js)   如何使用canvascanvas">
<meta property="og:updated_time" content="2017-12-12T08:50:19.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description" content="canvas 是HTML5新增的标签（画布）,功能特别强大  作用：  HTML5游戏大部分都是基于canvas开发的，还有一些交互性强的效果   炫酷的动效  webGL技术的实现（利用canvas在页面中绘制3D效果），three.js，计算机图形学  图片裁剪、修图、转base64，绘制图表做数据可视化(echarts highcharts d3.js)   如何使用canvascanvas">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-canvas" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/12/canvas/" class="article-date">
  <time datetime="2017-12-12T13:28:55.141Z" itemprop="datePublished">2017-12-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="canvas"><a href="#canvas" class="headerlink" title="canvas"></a>canvas</h3><blockquote>
<p>是HTML5新增的标签（画布）,功能特别强大</p>
</blockquote>
<p>作用：</p>
<ol>
<li><p>HTML5游戏大部分都是基于canvas开发的，还有一些交互性强的效果 </p>
</li>
<li><p>炫酷的动效</p>
</li>
<li><p>webGL技术的实现（利用canvas在页面中绘制3D效果），three.js，计算机图形学</p>
</li>
<li><p>图片裁剪、修图、转base64，绘制图表做数据可视化(echarts highcharts d3.js)</p>
</li>
</ol>
<h3 id="如何使用canvas"><a href="#如何使用canvas" class="headerlink" title="如何使用canvas"></a>如何使用canvas</h3><p>canvas是一个H5的标签，可以在内部通过js来绘制图形,绘制的图形都是==位图==</p>
<p>也仅仅是一个标签，绘图原理是：在canvas内部我们可以看做有一个透明的，高清的塑料布，在上面进行绘制</p>
<ol>
<li><p>给canvas设置宽高：</p>
<p> canvas标签的宽高默认是300*150,是一个行内块元素</p>
<p> 可以在canvas标签上通过width，height来设置</p>
<p> 可以在js中给dom对象设置：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      mycanvas.width = 500</span><br><span class="line">mycanvas.height = 500</span><br></pre></td></tr></table></figure>
<p> 切记，不要通过css来调整canvas的宽高,导致内部的canvas画布被拉伸，图形变形</p>
</li>
<li><p>获取画笔工具：</p>
<p> canvas绘图都是通过canvas标签的画笔来进行的</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var ctx = canvas.getContext(&apos;2d&apos;)</span><br></pre></td></tr></table></figure>
<p> 注意，不要写成getContent，里面传入的参数目前也只有2d这一种情况</p>
</li>
<li><p>描边和填充</p>
<p> canvas绘制图形都是绘制的路径，看不见摸不着的一种东西，需要进行描边或填充之后才能看到真正的图形</p>
<p> 如果绘制图形的路径在绘制完成后没有闭合，继续绘制路径的时候会首尾相连</p>
<p> 在填充的时候如果路径依然没有闭合，会将路径的闭合区域填充</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctx.fill()//填充</span><br><span class="line">ctx.stroke()//描边</span><br></pre></td></tr></table></figure>
<p> 可以调整ctx.strokeStyle,ctx.fillStyle属性来更改填充，描边的颜色，值为颜色值（rgb,rgba,word,16进制）</p>
</li>
<li><p>绘制矩形</p>
<p> ctx.rect(x,y,w,h)</p>
<p> canvas的坐标系起点是左上角，x轴向右正方向，y轴向下正方向</p>
<p> x,y代表的是矩形起点（左上角）的位置，w,h就是宽高</p>
<p> 可以使用strokeRect,fillRect方法直接绘制一个填充、描边的矩形</p>
</li>
<li><p>清楚矩形区域以及动画原理</p>
<p> ctx.clearRect(x,y,w,h)可以清除某一个矩形区域的图形</p>
<p> canvas实现动画的原理就是不断的绘制和擦除来实现</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">      var ctx = canvas.getContext(&quot;2d&quot;)</span><br><span class="line">let x=0,y=0;</span><br><span class="line">ctx.fillRect(x,y,50,50)	</span><br><span class="line">setInterval(function () &#123;</span><br><span class="line">	//绘制新的图形前擦掉之前的</span><br><span class="line">	ctx.clearRect(0,0,canvas.width,canvas.height)</span><br><span class="line">	x++;y++;</span><br><span class="line">	//不断绘制新图形</span><br><span class="line">	ctx.fillRect(x,y,50,50)</span><br><span class="line">&#125;,30)</span><br></pre></td></tr></table></figure>
</li>
<li><p>绘制圆弧、圆</p>
<p> ctx.arc(x,y,r,startangle,endangle,isAntiClockWise)<br> x,y是圆心的位置，r是半径，startangle，endangle是开始弧度和结束弧度，最后一个参数是是否是逆时针，默认是false</p>
</li>
</ol>
<ol>
<li><p>强行闭合路径</p>
<p> 有的时候绘制完成一个不闭合路径之后，又去绘制其他图形了。结果两个图形的路径连接在一起出现问题</p>
<p> 使用ctx.beginPath() 和ctx.closePath()两个方法将某一次绘制包裹起来后，此次绘制的路径会自动闭合</p>
</li>
<li><p>绘制线段</p>
<p> 可以使用moveTo(x,y)，lineTo(x,y)的方法来绘制线段</p>
<p> moveTo绘制起点，后面可以有多个lineTo来确定其他的点，如果没有moveTo，默认第一个lineTo绘制的就是起点</p>
<p> 通过lineWidth调整线宽，调整lineCap(butt,round,square)来更改接头的样式</p>
</li>
<li><p>save和restore<br> 可以通过save方法和restore方法来恢复画笔设置，减少产生bug的几率</p>
<p> save方法会保存此时画笔的设置，restore会恢复离的最近的save保存的设置</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">        ctx.save()//保存当前画笔的状态</span><br><span class="line">		ctx.fillStyle = &apos;red&apos;</span><br><span class="line">		ctx.fillRect(0,0,100,100)</span><br><span class="line">		ctx.restore()//恢复离的最近的save保存的状态</span><br><span class="line">    ``</span><br><span class="line">10. 曲线</span><br><span class="line"></span><br><span class="line">    canvas里提供了两种曲线的设置方法：贝塞尔曲线，二次样条曲线</span><br><span class="line"></span><br><span class="line">    ctx.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y)</span><br><span class="line"></span><br><span class="line">    cp1x,cp1y确定第一个控制点，cp2x，cp2y确定的是第二个控制点，x，y确定的是这条曲线的终点</span><br><span class="line"></span><br><span class="line">    ctx.quadraticCurveTo(cpx,cpy,x,y)</span><br><span class="line"></span><br><span class="line">    cpx,cpy确定控制点的坐标，x，y确定终点坐标</span><br><span class="line"></span><br><span class="line">    线条会像各个控制点的方向弯曲来形成曲线</span><br></pre></td></tr></table></figure>
<pre><code>ctx.moveTo(0,0)
ctx.bezierCurveTo(50,300,300,300,300,300)
ctx.quadraticCurveTo(50,300,300,300)

ctx.stroke()
</code></pre> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">11. 渐变</span><br><span class="line"></span><br><span class="line">    在canvas中，可以通过createLinearGradient、createRadialGradient创建线性、径向渐变</span><br><span class="line"></span><br><span class="line">    let lg = ctx.createLinearGradient(x1,y1,x2,y2)四个参数确定两个点，这两点点之间就是颜色渐变的区域</span><br><span class="line"></span><br><span class="line">    这个方法返回的是一个颜色值,这个颜色对象有addColorStop方法来添加颜色</span><br><span class="line"></span><br><span class="line">    lg.addColorStop(offset,color);offset是颜色的偏移量（颜色最深的地方），color是这个地方的颜色</span><br></pre></td></tr></table></figure>
<pre><code>let lg = ctx.createLinearGradient(50,0,250,0)

lg.addColorStop(0,&apos;red&apos;)
lg.addColorStop(0.5,&apos;yellow&apos;)
lg.addColorStop(1,&apos;blue&apos;)

ctx.fillStyle = lg
ctx.fillRect(0,0,300,300)
</code></pre> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">注意，渐变的颜色、区域都是提前定义好的，我们在设置的时候很可能只是显示出某一个区域的颜色渐变情况。</span><br><span class="line"></span><br><span class="line">ctx2.createRadialGradient(x0,y0,r0,x1,y1,r1)可以创建径向渐变</span><br><span class="line"></span><br><span class="line">六个参数确定两个圆，第一个是发散开始圆，第二个是发散结束圆</span><br></pre></td></tr></table></figure>
<pre><code>var rg = ctx2.createRadialGradient(50,150,50,200,150,150)

rg.addColorStop(0,&apos;red&apos;)
rg.addColorStop(0.5,&apos;yellow&apos;)
rg.addColorStop(1,&apos;blue&apos;)

ctx2.fillStyle = rg
ctx2.fillRect(0,0,300,300)
</code></pre> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">12. 图形整合方式</span><br><span class="line"></span><br><span class="line">    可以设置ctx.globalCompositeOperation值来控制新图形和原有图形叠加的情况</span><br></pre></td></tr></table></figure>
<p> var arr=[</p>
<pre><code>{type:&apos;source-over&apos;,des:&apos;在原有图形上绘制新图形&apos;},
{type:&apos;destination-over&apos;,des:&apos;在原有图形下绘制新图形&apos;},
{type:&apos;source-in&apos;,des:&apos;显示原有图形和新图形的交集，新图形在上，所以颜色为新图形的颜色&apos;},
{type:&apos;destination-in&apos;,des:&apos;显示原有图形和新图形的交集，原有图形在上，所以颜色为原有图形的颜色&apos;},
{type:&apos;source-out&apos;,des:&apos;只显示新图形非交集部分&apos;},
{type:&apos;destination-out&apos;,des:&apos;只显示原有图形非交集部分&apos;},
{type:&apos;source-atop&apos;,des:&apos;显示原有图形和交集部分，新图形在上，所以交集部分的颜色为新图形的颜色&apos;},
{type:&apos;destination-atop&apos;,des:&apos;显示新图形和交集部分，新图形在下，所以交集部分的颜色为原有图形的颜色&apos;},
{type:&apos;lighter&apos;,des:&apos;原有图形和新图形都显示，交集部分做颜色叠加&apos;},
{type:&apos;xor&apos;,des:&apos;重叠部分不显示&apos;},
{type:&apos;copy&apos;,des:&apos;只显示新图形&apos;}
</code></pre><p> ]</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">13. 绘制处理图片</span><br><span class="line"></span><br><span class="line">    canvas可以绘制出图片，并且对图片进行一系列的处理</span><br><span class="line"></span><br><span class="line">    画笔工具的drawImage方法可以对图片进行绘制</span><br><span class="line"></span><br><span class="line">    第一种方法：ctx.drawImage(img,x,y,w,h)；img为要绘制的图片对象，后面四个参数确定这张图片绘制在canvas画布上的哪个地方</span><br><span class="line"></span><br><span class="line">    第二种方法:ctx.drawImage(img,x1,y1,w1,h1,x,y,w,h)x,y,w,h确定绘制在画布上的哪个地方，前四个参数确定要绘制的是图片上的哪一个区域</span><br></pre></td></tr></table></figure>
<pre><code>var img = new Image()
img.src=&apos;./qqb.jpg&apos;
img.onload = function () {
    // ctx.drawImage(img,0,0,300,150)
    ctx.drawImage(img,214,213,214,213,0,0,300,150)
}
</code></pre> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    toDateUrl可以将canvas图形转换成base64编码，getImageData获取到图形像素点的信息</span><br><span class="line"></span><br><span class="line">14. 图形阴影</span><br><span class="line"></span><br><span class="line">    在canvas中可以像css3的box-shadow属性一样为图形绘制阴影</span><br></pre></td></tr></table></figure>
<p> ctx.shadowOffsetX = “50”; //  阴影x轴偏移量<br> ctx.shadowOffsetY = “5”;//        y轴的偏移量<br> ctx.shadowBlur = “5”;    //        模糊半径<br> ctx.shadowColor = “red”;//        阴影颜色</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">15. 绘制文字</span><br><span class="line"></span><br><span class="line">    ctx.font=&quot;normal 30px 微软雅黑&quot;;//设置字体的样式，顺序不能改style,size,family</span><br><span class="line">    ctx.textBaseline = &quot;middle&quot;;// top  bottom  middle 设置垂直对齐方式</span><br><span class="line">    ctx.textAlign = &quot;center&quot;;//设置水平对齐方式   left right center</span><br><span class="line"></span><br><span class="line">    // ctx.fillText(&quot;千锋H5&quot;,0,0);//（实心字）</span><br><span class="line">    ctx.strokeText(&quot;千锋H5&quot;,150,150)//（字的轮廓）;</span><br><span class="line"></span><br><span class="line">16. 变形</span><br><span class="line"></span><br><span class="line">    canvas可以通过对ctx设置translate，scale，rotate来对画布进行变形，注意的是，先旋转后唯一和先位移后旋转是不一样的</span><br></pre></td></tr></table></figure>
<pre><code>ctx.translate(x,y)//x，y轴偏移量
ctx.rotate(angel)//传入旋转的弧度
ctx.scale(x,y)//x，y轴缩放的倍数
</code></pre><p> ```</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/12/canvas/" data-id="cjb4wxo0z0001iwpwtp9b57zv" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/12/12/Project/cookie/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Neuer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/12/13/amazing_foo_question/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/12/12/Project/Project/README/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/12/12/Project/js/xqw/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/12/12/Project/js/ScrollPicLeft/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/12/12/Project/js/require/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>